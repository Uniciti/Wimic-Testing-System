import { Component, OnDestroy, OnInit, AfterViewInit } from '@angular/core';
import { RouterOutlet, NavigationEnd, Router } from "@angular/router";
import { NgClass } from "@angular/common";
import { HttpClientModule } from '@angular/common/http';
import { FormsModule } from '@angular/forms';

import { HeaderComponent } from './header/header.component';
import { SidebarComponent } from './sidebar/sidebar.component';
import { DeviceStatusComponent } from './deviceStatus/deviceStatus.component';
import { mainTestsComponent } from './mainTests/mainTests.component';
import { ConnectionStatusComponent } from './ConnectionStatus/ConnectionStatus.component';
import { QueueTestsFormComponent } from './queue-tests-form/queue-tests-form.component'

import { MessageService } from 'primeng/api';
import { FileUploadModule } from 'primeng/fileupload';
import { ToastModule } from 'primeng/toast';
// import { DynamicDialogModule, DialogService,
//   DynamicDialogRef, DynamicDialogConfig } from 'primeng/dynamicdialog';

import { SharedWebSocketService } from './SharedWebSocket.service';
import { ConnectionStatusService } from './core/services/ConnectionStatus.service';
import { NotificationService } from './Notification.service';
import { TabStateService } from './app.component.service'
// import { QueueTestsFormService } from './queue-tests-form/queue-tests-form.service';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    FormsModule,
    HeaderComponent,
    NgClass,
    SidebarComponent, 
    DeviceStatusComponent, 
    mainTestsComponent,
    ConnectionStatusComponent, 
    RouterOutlet, 
    QueueTestsFormComponent,
    FileUploadModule,
    ToastModule,
    HttpClientModule
    //DynamicDialogModule
    ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css' ],
  styles: [`
  .tab_content{height: screen;
    overflow-y: scroll;
    -ms-overflow-style: none; 
    scrollbar-width: none}
  .tab-content::-webkit-scrollbar{display: none}`
  ],
  providers: [ NotificationService,
    MessageService,
    ConnectionStatusService
    // DynamicDialogRef,
    // DialogService,
    // DynamicDialogConfig
  ]
})
export class AppComponent implements OnInit, OnDestroy, AfterViewInit {

  // tabName: string;
  // tabData: any = {};

  constructor(
    private sharedWebSocketService: SharedWebSocketService,
    private connectionStatusService: ConnectionStatusService,
    private notificationService: NotificationService,
    private router: Router,
    private tabStateService: TabStateService,
  ) { }

  // setTabName(tabName: string): void {
  //   this.tabName = tabName;
  // }

  // private observableWebSocket: Observable<> = new Observable();
  ngOnInit(): void {
    // if (this.tabName) {
    //   this.tabData = this.tabStateService.getState(this.tabName) || {};
    // }
    this.sharedWebSocketService.connect();
    this.sharedWebSocketService.getMessages().subscribe(message_ => {
      console.log(message_);
    if (message_.type === "is-connected") {
      if (message_.pingBert == false) {
        this.connectionStatusService.updateStatus("Ber", false);
        this.notificationService.showError("Беркут-ЕТ отключился...");
      }
      if (message_.pingAtt == false) {
        this.connectionStatusService.updateStatus("Att", false);
        this.notificationService.showError("Аттенюатор отключился...");
      }
      if (message_.pingStat0 == false || message_.pingStat1 == false) {
        this.connectionStatusService.updateStatus("Stat", false);
        this.notificationService.showError("Станции или одна из них отключились...");
      }
      if (message_.pingM3M == false) {
        this.connectionStatusService.updateStatus("M3M", false);
        this.notificationService.showError("М3М отключился...");
      }
    }})
  }

  ngAfterViewInit() {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationEnd) {
        this.resetScrollPosition();
      }
    });
  }

  resetScrollPosition() {
    const tabContent = document.querySelector('.tab_content');
    if (tabContent) {
      tabContent.scrollTop = 0;
    }
  }

  ngOnDestroy(): void {
    // if (this.tabName) {
    //   this.tabStateService.setState(this.tabName, this.tabData);
    // }
    this.sharedWebSocketService.disconnect();
  } 
}

import { Component, OnInit, ChangeDetectorRef, OnDestroy,
   NgZone } from '@angular/core';
import { NgClass, NgFor, CommonModule } from "@angular/common";
import { FormsModule } from '@angular/forms';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { Subscription, timer } from 'rxjs';

import { InputNumberModule } from 'primeng/inputnumber';
import { ButtonModule } from 'primeng/button';
import { SelectButtonModule } from 'primeng/selectbutton';
import { ToastModule } from 'primeng/toast';
import { ProgressBarModule } from 'primeng/progressbar'
import { FileUploadModule } from 'primeng/fileupload';

import { SharedWebSocketService } from '../SharedWebSocket.service';
import { NotificationService } from '../Notification.service';
import { FileSaveService } from './fileSaver.service';
import { TabStateService } from '../app.component.service';

import { QueueTestsFormComponent } from "../queue-tests-form/queue-tests-form.component"
//import { DialogService, DynamicDialogRef } from 'primeng/dynamicdialog';
import { PullTestsInterface } from '../core/interfaces/pull_tests'

@Component({
  selector: 'app-mainTests',
  standalone: true,
  imports: [
    NgClass,
    NgFor,
    CommonModule,
    FormsModule,
    MatDialogModule,
    InputNumberModule,
    ButtonModule,
    ProgressBarModule,
    SelectButtonModule,
    ToastModule,
    QueueTestsFormComponent,
    FileUploadModule
  ],
  templateUrl: './mainTests.component.html',
  styleUrls: ['./mainTests.component.css'],
  styles: [`.tab_content{height: 38rem; overflow-y: scroll;}`],
  providers: [ NotificationService ]
})

export class mainTestsComponent implements OnInit, OnDestroy {

  mainTestsData: any = {};

  loadingTest: boolean = false;
  TestProcessing: boolean = false;
  interval: any;
  modulation: number = 0;
  // selectionTestType: string = "express_test"
  // selectionBandwidth: number =  3;
  pa1: number | null = null;
  pa2: number | null = null;
  splitterM3M: number | null = null;
  splitterST: number | null = null;
  cable1: number | null = null;
  cable2: number | null = null;
  cable3: number | null = null;
  //duration: number | null = null;
  parsedData: any;

  // pullman_tests: PullTestsInterface = {
  //   "modulation": "",
  //   "bandwidth": "",
  //   "frequncy": "none",
  //   "type": "",
  //   "time": ""
  // }

  massiveTests = []
  //ref: DynamicDialogRef | null = null;

  /*
    modulation: all, bpsk1/2, qpsk3/4...
    bandwidth: 3, 5
    frequency: 1124, ...
    type: full, express
  */
  testOptions: any[] = [{ label: 'Экспресс тест', value: "express_test" },{ label: 'Полный тест', value: "full_test" }];
  stationOptions: any[] = [{ label: '10 МГц', value: 3 },{ label: '20 МГц', value: 5 }];
  
  private subscription: Subscription = new Subscription();

  constructor(
    private sharedWebSocketService: SharedWebSocketService,
    private cdr: ChangeDetectorRef,
    private notificationService: NotificationService,
    private ngZone: NgZone,
    private dialog: MatDialog,
    private fileSaveService: FileSaveService,
    private tabStateService: TabStateService
  ) {  }

  openDialog() {
    const dialogRef = this.dialog.open(QueueTestsFormComponent, {
      width: '750px',
      height: '800px',
      panelClass: 'FormStyle'
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        this.massiveTests = result;
      }
    });
  }

  uploadJSONWithSettings(event: any) {
    const file = event.files[0];
    const reader = new FileReader();
    reader.onload = (e: any) => {
      try {
        this.parsedData = JSON.parse(e.target.result);
        this.massiveTests = [];
        this.massiveTests = this.parsedData[0];
        console.log(this.massiveTests);
        this.pa1 = this.parsedData[1]["Attenuator_PA1"];
        this.pa2 = this.parsedData[1]["Attenuator_PA2"];
        this.splitterM3M = this.parsedData[1]["splitter_to_M3M"];
        this.splitterST = this.parsedData[1]["splitter_straight"];
        this.cable1 = this.parsedData[1]["cable1"];
        this.cable2 = this.parsedData[1]["cable2"];
        this.cable3 = this.parsedData[1]["cable3"];
        // Здесь вы можете присвоить данные другим переменным
      } catch (error) {
        console.error('Ошибка при парсинге JSON:', error);
      }
    };
    reader.readAsText(file);
  }

  downloadJSONWithSettings() {
    const settingsData : any = {
      Attenuator_PA1: this.pa1,
      Attenuator_PA2: this.pa2,
      splitter_to_M3M: this.splitterM3M,
      splitter_straight: this.splitterST,
      cable1: this.cable1,
      cable2: this.cable2,
      cable3: this.cable3,
    }

    const jsonDataSettings = this.massiveTests.concat(settingsData);
    const blob = new Blob([JSON.stringify(jsonDataSettings, null, 2)], {type: 'application/json' });
    this.fileSaveService.saveFile(blob);
  }

  ngOnInit(): void { 
    this.mainTestsData = this.tabStateService.getState('mainTests') || {};
  }

  ngOnDestroy() {
    this.tabStateService.setState('mainTests', this.mainTestsData);
  }

  buttonsControlTest(sub:  Subscription) {
    this.TestProcessing = false;
    this.loadingTest = false;
    this.cdr.detectChanges();
    sub.unsubscribe();
  }

  pullman() {
    this.ngZone.runOutsideAngular(() => {
      this.interval = setInterval(() => {
        this.ngZone.run(() => {
          let subscription = this.sharedWebSocketService.getMessages().subscribe({
            next: (message) => {
              if (message.status === "modulation") {
                this.modulation = ((message.currentMod / message.stage) * 100) - 1;
                if (message.status === "completed") {
                  this.modulation = 0;
                  this.notificationService.showSuccess("Тестирование успешно завершено, проверьте папку tests...");
                  subscription.unsubscribe();
                  clearInterval(this.interval);
                }
              }
            },
            error: (error) => {
              this.TestProcessing = false;
              this.loadingTest = false;
              subscription.unsubscribe();
              clearInterval(this.interval);
          }});
          this.subscription.add(subscription);
        });
      }, 2000);
    });
  }

  startTest(Queue_tests: any[]) {
    this.loadingTest = true;
    const InputedParams = 
    {
      Attenuator_PA1: this.pa1,
      Attenuator_PA2: this.pa2,
      splitterM3M: this.splitterST,
      splitter_straight: this.splitterM3M,
      cable1: this.cable1,
      cable2: this.cable2,
      cable3: this.cable3,
      //duration: this.duration,
      //bandwidth: this.selectionBandwidth
    };

    const message = {"type": "test", "params": Queue_tests, "command": InputedParams};
    this.sharedWebSocketService.sendMessage(message);

    const connectionTimeout = timer(5000).subscribe(() => {
      this.loadingTest = false;
      connectionTimeout.unsubscribe();
    });

    let subscription = this.sharedWebSocketService.getMessages().subscribe({
      next: (message) => {
        if (message.type === "sended" && message.type === "test") {
          this.pullman();
          connectionTimeout.unsubscribe();
          this.TestProcessing = true;
          if (message.status !== "completed") {
            this.notificationService.showError('Проверьте подключение к устройствам');
          }
        } 
          this.buttonsControlTest(subscription);
      },
      error: (error) => {
        connectionTimeout.unsubscribe();
        this.notificationService.showError('Проверьте подключение к устройствам');
        this.buttonsControlTest(subscription);
      }
    });
    this.subscription.add(subscription);
  }
}

import { Component, OnInit, ChangeDetectorRef, OnDestroy } from '@angular/core';
import { NgClass } from "@angular/common";
import { FormsModule } from '@angular/forms';
import { NgIf } from "@angular/common";
import { Subscription, timer } from 'rxjs';

import { ButtonModule } from 'primeng/button';
import { SelectButtonModule } from 'primeng/selectbutton';
import { InputNumberModule } from 'primeng/inputnumber';
import { InputTextModule } from 'primeng/inputtext';
import { ToastModule } from 'primeng/toast';

import { SharedWebSocketService } from '../SharedWebSocket.service';
import { ConnectionStatusService } from '../core/services/ConnectionStatus.service';
import { NotificationService } from '../Notification.service';
import { TabStateService } from '../app.component.service';


@Component({
  selector: 'app-deviceStatus',
  standalone: true,
  imports: [
    NgClass,
    FormsModule,
    NgIf,
    ButtonModule,
    SelectButtonModule,
    InputNumberModule,
    InputTextModule,
    ToastModule
  ],
  templateUrl: './deviceStatus.component.html',
  styleUrls: ['./deviceStatus.component.css'],
  styles: [`.tab_content{height: 70.5rem; overflow-y: scroll;}`],
  providers: [ NotificationService ]
})

export class DeviceStatusComponent implements OnInit, OnDestroy {
  //deviceConnected: boolean =  false;
  deviceStatusData: any = {};

  inputIP_BASE: string = '';
  inputIP_ABONENT: string = '';
  inputFrequency: string = '5600000';
  inputOffset: string = '';

  loadingButtons: {[key: string] : boolean} = {
    "Att": false,
    "Ber": false,
    "Stat": false,
    "M3M": false,
    "StatIP": false,
    "StatOID": false,
    "M3Moffset": false
  }

  connectionsButtons: {[key: string] : boolean} = {
    "Att": false,
    "Ber": false,
    "Stat": false,
    "M3M": false
  }

  private subscription: Subscription = new Subscription();
  
  constructor(
    private sharedWebSocketService: SharedWebSocketService, 
    private connectionStatusService: ConnectionStatusService,
    private notificationService: NotificationService,
    private cdr: ChangeDetectorRef,
    private tabStateService: TabStateService
  ) {}
 
  ngOnInit() {
    this.deviceStatusData = this.tabStateService.getState('deviceStatus') || {};
  };

  ngOnDestroy() {
    this.tabStateService.setState('deviceStatus', this.deviceStatusData);
  }

  buttonControlDevice(device: string, _status: boolean, sub: Subscription) {
    this.loadingButtons[device] = false;
    this.connectionsButtons[device] = _status;
    //this.deviceConnected = _connected;
    this.cdr.detectChanges();
    sub.unsubscribe();
  }

  connectToDevice(device: string) {
    this.loadingButtons[device] = true;       //ХУЙ ЗНАЕТ , МБ НЕ РАБОТАЕТ , ТОЛЯН СКАЩАЛ, ЧТО НОРМАС ВРОДЕ
    const message = { "type": "connect", "deviceId": device };
    this.sharedWebSocketService.sendMessage(message);

    const timeout = timer(5000).subscribe(() => {
      this.loadingButtons[device] = false;
      timeout.unsubscribe();
    });

    let subscription = this.sharedWebSocketService.getMessages().subscribe({
      next: (message) => {
        if (message.type === "connect" && message.deviceId === device && message.conStatus == true) {
          console.log(message);
          this.connectionStatusService.updateStatus(device, true);
          this.buttonControlDevice(device,true, subscription);
          timeout.unsubscribe();
        } else {
          this.notificationService.showError('Ошибка подключения к устройству');
          this.buttonControlDevice(device,false, subscription);
          timeout.unsubscribe();
        }
      },
      error: (error) => {
        this.notificationService.showError('Ошибка подключения к устройству');
        this.buttonControlDevice(device,false, subscription);
        timeout.unsubscribe();
      }
    });
    this.subscription.add(subscription);
  }

  disconnectToDevice(device: string) {
    this.loadingButtons[device] = true;
    const message = { "type": "disconnect", "deviceId": device };
    this.sharedWebSocketService.sendMessage(message);

    const timeout = timer(5000).subscribe(() => {
      this.loadingButtons[device] = false;
      timeout.unsubscribe();
    });

    let subscription = this.sharedWebSocketService.getMessages().subscribe({
      next: (message) => {
      if (message.type === "disconnect" && message.deviceId === device) {
        this.connectionStatusService.updateStatus(device, false);
        this.buttonControlDevice(device,false, subscription);
        timeout.unsubscribe();
      }
      else {
        this.notificationService.showError('Ошибка отключения от устройства');
        this.buttonControlDevice(device,true, subscription);
        timeout.unsubscribe();
      }
    }, error: (error) => {
      this.notificationService.showError('Ошибка отключения от устройства');
      this.buttonControlDevice(device,true , subscription);
      timeout.unsubscribe();
    }
    });
    this.subscription.add(subscription); // Добавляем подписку в общий объект подписок
  }

  validateIpAddress(ip: string): boolean {
    const ipPattern = /^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}$/;
    return ipPattern.test(ip);
  }

  swapMode() {
    const temp = this.inputIP_BASE;
    this.inputIP_BASE = this.inputIP_ABONENT;
    this.inputIP_ABONENT = temp;
    this.cdr.detectChanges();
    console.log('Роли сменены: BASE ->', this.inputIP_BASE, ', ABONENT ->', this.inputIP_ABONENT);
  }

  sendParams(device: string) {
    this.loadingButtons[device] = true;
    let InputedParams: {[key: string]: string} = { "" : ""};
    switch(device) {
      case "StatOID": 
        InputedParams = {
          "frequency": this.inputFrequency,
        };
        break;
      case "StatIP":
        InputedParams = {
          "baseIP": this.inputIP_BASE,
          "abonentIP": this.inputIP_ABONENT
        };

        if ((this.inputIP_ABONENT && this.inputIP_BASE) == '') {
          this.notificationService.showWarning('Введите IP адрес для станций ');
          return;
        } 
    
        const isBaseValid = this.validateIpAddress(this.inputIP_BASE);
        const isAbonentValid = this.validateIpAddress(this.inputIP_ABONENT);
    
        if (!isBaseValid || !isAbonentValid) {
          this.notificationService.showWarning('Некорректный ввод IP адресов для станций ');
          return;
        }
        break;
      case "M3Moffset":
        InputedParams = {
          "offset": this.inputOffset
        };
        break;
    };

    const message = {"type": "send-command", "deviceId": device, "command": InputedParams};
    this.sharedWebSocketService.sendMessage(message);

    const timeout = timer(5000).subscribe(() => {
      this.loadingButtons[device] = false;
      timeout.unsubscribe();
    });

    let subscription = this.sharedWebSocketService.getMessages().subscribe({
      next: (message) => {
      if (message.type === "sended" && message.deviceId === device) {
        this.loadingButtons[device] = false;
        switch(device) {
          case "StatOID":
            this.connectionStatusService.changeOidParamsStatus(InputedParams["frequency"]);
            break;
          case "StatIP":
            this.connectionStatusService.changeIpParamsStatus(InputedParams["baseIP"], InputedParams["abonentIP"]);
            break;
          case "M3Moffset":
            this.connectionStatusService.changeOffsetM3MStatus(InputedParams["offset"]);
            break;
        }
        this.cdr.detectChanges();
        subscription.unsubscribe();
        timeout.unsubscribe();
      } else {
        this.notificationService.showError('Ошибка установки параметров');
        this.loadingButtons[device] = false;
        this.cdr.detectChanges();
      }
    }, error: (error) => {
      this.loadingButtons[device] = false;
      this.notificationService.showError('Ошибка установки параметров');
      this.cdr.detectChanges();
      subscription.unsubscribe();
      timeout.unsubscribe();
    }
    });
    this.subscription.add(subscription);
  }
}